{"ast":null,"code":"var isContextArray = function isContextArray(value) {\n  return Array.isArray(value);\n};\n\nvar isContext = function isContext(value) {\n  return !Array.isArray(value) && typeof value === 'object' && value !== null;\n};\n\nexport function combine() {\n  var sources = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    sources[_i] = arguments[_i];\n  }\n\n  var destination;\n\n  for (var _a = 0, sources_1 = sources; _a < sources_1.length; _a++) {\n    var source = sources_1[_a]; // Ignore any undefined or null sources.\n\n    if (source === undefined || source === null) {\n      continue;\n    }\n\n    destination = mergeInto(destination, source, createCircularReferenceChecker());\n  }\n\n  return destination;\n}\n/*\n * Performs a deep clone of objects and arrays.\n * - Circular references are replaced by 'undefined'\n */\n\nexport function deepClone(context) {\n  return mergeInto(undefined, context, createCircularReferenceChecker());\n}\nexport function createCircularReferenceChecker() {\n  if (typeof WeakSet !== 'undefined') {\n    var set_1 = new WeakSet();\n    return {\n      hasAlreadyBeenSeen: function hasAlreadyBeenSeen(value) {\n        var has = set_1.has(value);\n\n        if (!has) {\n          set_1.add(value);\n        }\n\n        return has;\n      }\n    };\n  }\n\n  var array = [];\n  return {\n    hasAlreadyBeenSeen: function hasAlreadyBeenSeen(value) {\n      var has = array.indexOf(value) >= 0;\n\n      if (!has) {\n        array.push(value);\n      }\n\n      return has;\n    }\n  };\n}\n/**\n * Iterate over 'source' and affect its subvalues into 'destination', recursively.  If the 'source'\n * and 'destination' can't be merged, return 'source'.\n */\n\nexport function mergeInto(destination, source, circularReferenceChecker) {\n  // Ignore the 'source' if it is undefined\n  if (source === undefined) {\n    return destination;\n  } // If the 'source' is not an object or array, it can't be merged with 'destination' in any way, so\n  // return it directly.\n\n\n  if (!isContext(source) && !isContextArray(source)) {\n    return source;\n  } // Return 'undefined' if we already iterated over this 'source' to avoid infinite recursion\n\n\n  if (circularReferenceChecker.hasAlreadyBeenSeen(source)) {\n    return undefined;\n  } // 'source' and 'destination' are objects, merge them together\n\n\n  if (isContext(source) && (destination === undefined || isContext(destination))) {\n    var finalDestination = destination || {};\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        finalDestination[key] = mergeInto(finalDestination[key], source[key], circularReferenceChecker);\n      }\n    }\n\n    return finalDestination;\n  } // 'source' and 'destination' are arrays, merge them together\n\n\n  if (isContextArray(source) && (destination === undefined || isContextArray(destination))) {\n    var finalDestination = destination || [];\n    finalDestination.length = Math.max(finalDestination.length, source.length);\n\n    for (var index = 0; index < source.length; index += 1) {\n      finalDestination[index] = mergeInto(finalDestination[index], source[index], circularReferenceChecker);\n    }\n\n    return finalDestination;\n  } // The destination in not an array nor an object, so we can't merge it\n\n\n  return source;\n}","map":{"version":3,"sources":["../../src/tools/context.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var isContextArray = function (value) { return Array.isArray(value); };\nvar isContext = function (value) {\n    return !Array.isArray(value) && typeof value === 'object' && value !== null;\n};\nexport function combine() {\n    var sources = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        sources[_i] = arguments[_i];\n    }\n    var destination;\n    for (var _a = 0, sources_1 = sources; _a < sources_1.length; _a++) {\n        var source = sources_1[_a];\n        // Ignore any undefined or null sources.\n        if (source === undefined || source === null) {\n            continue;\n        }\n        destination = mergeInto(destination, source, createCircularReferenceChecker());\n    }\n    return destination;\n}\n/*\n * Performs a deep clone of objects and arrays.\n * - Circular references are replaced by 'undefined'\n */\nexport function deepClone(context) {\n    return mergeInto(undefined, context, createCircularReferenceChecker());\n}\nexport function createCircularReferenceChecker() {\n    if (typeof WeakSet !== 'undefined') {\n        var set_1 = new WeakSet();\n        return {\n            hasAlreadyBeenSeen: function (value) {\n                var has = set_1.has(value);\n                if (!has) {\n                    set_1.add(value);\n                }\n                return has;\n            },\n        };\n    }\n    var array = [];\n    return {\n        hasAlreadyBeenSeen: function (value) {\n            var has = array.indexOf(value) >= 0;\n            if (!has) {\n                array.push(value);\n            }\n            return has;\n        },\n    };\n}\n/**\n * Iterate over 'source' and affect its subvalues into 'destination', recursively.  If the 'source'\n * and 'destination' can't be merged, return 'source'.\n */\nexport function mergeInto(destination, source, circularReferenceChecker) {\n    // Ignore the 'source' if it is undefined\n    if (source === undefined) {\n        return destination;\n    }\n    // If the 'source' is not an object or array, it can't be merged with 'destination' in any way, so\n    // return it directly.\n    if (!isContext(source) && !isContextArray(source)) {\n        return source;\n    }\n    // Return 'undefined' if we already iterated over this 'source' to avoid infinite recursion\n    if (circularReferenceChecker.hasAlreadyBeenSeen(source)) {\n        return undefined;\n    }\n    // 'source' and 'destination' are objects, merge them together\n    if (isContext(source) && (destination === undefined || isContext(destination))) {\n        var finalDestination = destination || {};\n        for (var key in source) {\n            if (Object.prototype.hasOwnProperty.call(source, key)) {\n                finalDestination[key] = mergeInto(finalDestination[key], source[key], circularReferenceChecker);\n            }\n        }\n        return finalDestination;\n    }\n    // 'source' and 'destination' are arrays, merge them together\n    if (isContextArray(source) && (destination === undefined || isContextArray(destination))) {\n        var finalDestination = destination || [];\n        finalDestination.length = Math.max(finalDestination.length, source.length);\n        for (var index = 0; index < source.length; index += 1) {\n            finalDestination[index] = mergeInto(finalDestination[index], source[index], circularReferenceChecker);\n        }\n        return finalDestination;\n    }\n    // The destination in not an array nor an object, so we can't merge it\n    return source;\n}\n//# sourceMappingURL=context.js.map"]},"metadata":{},"sourceType":"module"}