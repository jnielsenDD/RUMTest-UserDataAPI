{"ast":null,"code":"import { __assign, __spreadArrays } from \"tslib\";\nimport { resetFetchProxy, startFetchProxy } from '../browser/fetchProxy';\nimport { resetXhrProxy, startXhrProxy } from '../browser/xhrProxy';\nimport { ErrorSource, formatUnknownError, toStackTraceString, formatErrorMessage, ErrorHandling } from '../tools/error';\nimport { Observable } from '../tools/observable';\nimport { clocksNow } from '../tools/timeUtils';\nimport { jsonStringify, RequestType, find } from '../tools/utils';\nimport { monitor } from './internalMonitoring';\nimport { computeStackTrace, subscribe, unsubscribe } from './tracekit';\nvar errorObservable;\nexport function startAutomaticErrorCollection(configuration) {\n  if (!errorObservable) {\n    errorObservable = new Observable();\n    trackNetworkError(configuration, errorObservable);\n    startConsoleTracking(errorObservable);\n    startRuntimeErrorTracking(errorObservable);\n  }\n\n  return errorObservable;\n}\nvar originalConsoleError;\n/* eslint-disable no-console */\n\nexport function startConsoleTracking(errorObservable) {\n  originalConsoleError = console.error;\n  console.error = monitor(function () {\n    var params = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      params[_i] = arguments[_i];\n    }\n\n    originalConsoleError.apply(console, params);\n    errorObservable.notify(__assign(__assign({}, buildErrorFromParams(params)), {\n      source: ErrorSource.CONSOLE,\n      startClocks: clocksNow(),\n      handling: ErrorHandling.HANDLED\n    }));\n  });\n}\nexport function stopConsoleTracking() {\n  console.error = originalConsoleError;\n}\n/* eslint-enable no-console */\n\nfunction buildErrorFromParams(params) {\n  var firstErrorParam = find(params, function (param) {\n    return param instanceof Error;\n  });\n  return {\n    message: __spreadArrays(['console error:'], params).map(function (param) {\n      return formatConsoleParameters(param);\n    }).join(' '),\n    stack: firstErrorParam ? toStackTraceString(computeStackTrace(firstErrorParam)) : undefined\n  };\n}\n\nfunction formatConsoleParameters(param) {\n  if (typeof param === 'string') {\n    return param;\n  }\n\n  if (param instanceof Error) {\n    return formatErrorMessage(computeStackTrace(param));\n  }\n\n  return jsonStringify(param, undefined, 2);\n}\n\nvar traceKitReportHandler;\nexport function startRuntimeErrorTracking(errorObservable) {\n  traceKitReportHandler = function traceKitReportHandler(stackTrace, _, errorObject) {\n    var _a = formatUnknownError(stackTrace, errorObject, 'Uncaught'),\n        stack = _a.stack,\n        message = _a.message,\n        type = _a.type;\n\n    errorObservable.notify({\n      message: message,\n      stack: stack,\n      type: type,\n      source: ErrorSource.SOURCE,\n      startClocks: clocksNow(),\n      originalError: errorObject,\n      handling: ErrorHandling.UNHANDLED\n    });\n  };\n\n  subscribe(traceKitReportHandler);\n}\nexport function stopRuntimeErrorTracking() {\n  unsubscribe(traceKitReportHandler);\n}\nexport function trackNetworkError(configuration, errorObservable) {\n  startXhrProxy().onRequestComplete(function (context) {\n    return handleCompleteRequest(RequestType.XHR, context);\n  });\n  startFetchProxy().onRequestComplete(function (context) {\n    return handleCompleteRequest(RequestType.FETCH, context);\n  });\n\n  function handleCompleteRequest(type, request) {\n    if (!configuration.isIntakeUrl(request.url) && (!configuration.isEnabled('remove-network-errors') || !request.isAborted) && (isRejected(request) || isServerError(request))) {\n      errorObservable.notify({\n        message: format(type) + \" error \" + request.method + \" \" + request.url,\n        resource: {\n          method: request.method,\n          statusCode: request.status,\n          url: request.url\n        },\n        source: ErrorSource.NETWORK,\n        stack: truncateResponseText(request.responseText, configuration) || 'Failed to load',\n        startClocks: request.startClocks\n      });\n    }\n  }\n\n  return {\n    stop: function stop() {\n      resetXhrProxy();\n      resetFetchProxy();\n    }\n  };\n}\n\nfunction isRejected(request) {\n  return request.status === 0 && request.responseType !== 'opaque';\n}\n\nfunction isServerError(request) {\n  return request.status >= 500;\n}\n\nfunction truncateResponseText(responseText, configuration) {\n  if (responseText && responseText.length > configuration.requestErrorResponseLengthLimit) {\n    return responseText.substring(0, configuration.requestErrorResponseLengthLimit) + \"...\";\n  }\n\n  return responseText;\n}\n\nfunction format(type) {\n  if (RequestType.XHR === type) {\n    return 'XHR';\n  }\n\n  return 'Fetch';\n}","map":{"version":3,"sources":["../../src/domain/automaticErrorCollection.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __assign, __spreadArrays } from \"tslib\";\nimport { resetFetchProxy, startFetchProxy } from '../browser/fetchProxy';\nimport { resetXhrProxy, startXhrProxy } from '../browser/xhrProxy';\nimport { ErrorSource, formatUnknownError, toStackTraceString, formatErrorMessage, ErrorHandling, } from '../tools/error';\nimport { Observable } from '../tools/observable';\nimport { clocksNow } from '../tools/timeUtils';\nimport { jsonStringify, RequestType, find } from '../tools/utils';\nimport { monitor } from './internalMonitoring';\nimport { computeStackTrace, subscribe, unsubscribe } from './tracekit';\nvar errorObservable;\nexport function startAutomaticErrorCollection(configuration) {\n    if (!errorObservable) {\n        errorObservable = new Observable();\n        trackNetworkError(configuration, errorObservable);\n        startConsoleTracking(errorObservable);\n        startRuntimeErrorTracking(errorObservable);\n    }\n    return errorObservable;\n}\nvar originalConsoleError;\n/* eslint-disable no-console */\nexport function startConsoleTracking(errorObservable) {\n    originalConsoleError = console.error;\n    console.error = monitor(function () {\n        var params = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            params[_i] = arguments[_i];\n        }\n        originalConsoleError.apply(console, params);\n        errorObservable.notify(__assign(__assign({}, buildErrorFromParams(params)), { source: ErrorSource.CONSOLE, startClocks: clocksNow(), handling: ErrorHandling.HANDLED }));\n    });\n}\nexport function stopConsoleTracking() {\n    console.error = originalConsoleError;\n}\n/* eslint-enable no-console */\nfunction buildErrorFromParams(params) {\n    var firstErrorParam = find(params, function (param) { return param instanceof Error; });\n    return {\n        message: __spreadArrays(['console error:'], params).map(function (param) { return formatConsoleParameters(param); }).join(' '),\n        stack: firstErrorParam ? toStackTraceString(computeStackTrace(firstErrorParam)) : undefined,\n    };\n}\nfunction formatConsoleParameters(param) {\n    if (typeof param === 'string') {\n        return param;\n    }\n    if (param instanceof Error) {\n        return formatErrorMessage(computeStackTrace(param));\n    }\n    return jsonStringify(param, undefined, 2);\n}\nvar traceKitReportHandler;\nexport function startRuntimeErrorTracking(errorObservable) {\n    traceKitReportHandler = function (stackTrace, _, errorObject) {\n        var _a = formatUnknownError(stackTrace, errorObject, 'Uncaught'), stack = _a.stack, message = _a.message, type = _a.type;\n        errorObservable.notify({\n            message: message,\n            stack: stack,\n            type: type,\n            source: ErrorSource.SOURCE,\n            startClocks: clocksNow(),\n            originalError: errorObject,\n            handling: ErrorHandling.UNHANDLED,\n        });\n    };\n    subscribe(traceKitReportHandler);\n}\nexport function stopRuntimeErrorTracking() {\n    unsubscribe(traceKitReportHandler);\n}\nexport function trackNetworkError(configuration, errorObservable) {\n    startXhrProxy().onRequestComplete(function (context) { return handleCompleteRequest(RequestType.XHR, context); });\n    startFetchProxy().onRequestComplete(function (context) { return handleCompleteRequest(RequestType.FETCH, context); });\n    function handleCompleteRequest(type, request) {\n        if (!configuration.isIntakeUrl(request.url) &&\n            (!configuration.isEnabled('remove-network-errors') || !request.isAborted) &&\n            (isRejected(request) || isServerError(request))) {\n            errorObservable.notify({\n                message: format(type) + \" error \" + request.method + \" \" + request.url,\n                resource: {\n                    method: request.method,\n                    statusCode: request.status,\n                    url: request.url,\n                },\n                source: ErrorSource.NETWORK,\n                stack: truncateResponseText(request.responseText, configuration) || 'Failed to load',\n                startClocks: request.startClocks,\n            });\n        }\n    }\n    return {\n        stop: function () {\n            resetXhrProxy();\n            resetFetchProxy();\n        },\n    };\n}\nfunction isRejected(request) {\n    return request.status === 0 && request.responseType !== 'opaque';\n}\nfunction isServerError(request) {\n    return request.status >= 500;\n}\nfunction truncateResponseText(responseText, configuration) {\n    if (responseText && responseText.length > configuration.requestErrorResponseLengthLimit) {\n        return responseText.substring(0, configuration.requestErrorResponseLengthLimit) + \"...\";\n    }\n    return responseText;\n}\nfunction format(type) {\n    if (RequestType.XHR === type) {\n        return 'XHR';\n    }\n    return 'Fetch';\n}\n//# sourceMappingURL=automaticErrorCollection.js.map"]},"metadata":{},"sourceType":"module"}