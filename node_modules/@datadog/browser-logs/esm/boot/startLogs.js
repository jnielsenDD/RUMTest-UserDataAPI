import { areCookiesAuthorized, Batch, combine, commonInit, createErrorFilter, HttpRequest, limitModification, Observable, startAutomaticErrorCollection, } from '@datadog/browser-core';
import { StatusType } from '../domain/logger';
import { startLoggerSession } from '../domain/loggerSession';
import { buildEnv } from './buildEnv';
var FIELDS_WITH_SENSITIVE_DATA = ['view.url', 'view.referrer', 'message', 'error.stack', 'http.url'];
export function startLogs(userConfiguration, errorLogger, getGlobalContext) {
    var _a = commonInit(userConfiguration, buildEnv), configuration = _a.configuration, internalMonitoring = _a.internalMonitoring;
    var errorObservable = userConfiguration.forwardErrorsToLogs !== false
        ? startAutomaticErrorCollection(configuration)
        : new Observable();
    var session = startLoggerSession(configuration, areCookiesAuthorized(configuration.cookieOptions));
    return doStartLogs(configuration, errorObservable, internalMonitoring, session, errorLogger, getGlobalContext);
}
export function doStartLogs(configuration, errorObservable, internalMonitoring, session, errorLogger, getGlobalContext) {
    internalMonitoring.setExternalContextProvider(function () {
        return combine({ session_id: session.getId() }, getGlobalContext(), getRUMInternalContext());
    });
    var assemble = buildAssemble(session, configuration, reportError);
    var batch = startLoggerBatch(configuration);
    function reportError(error) {
        errorLogger.error(error.message, combine({
            date: error.startClocks.timeStamp,
            error: {
                kind: error.type,
                origin: error.source,
                stack: error.stack,
            },
        }, error.resource
            ? {
                http: {
                    method: error.resource.method,
                    status_code: error.resource.statusCode,
                    url: error.resource.url,
                },
            }
            : undefined, getRUMInternalContext(error.startClocks.relative)));
    }
    errorObservable.subscribe(reportError);
    return function (message, currentContext) {
        var contextualizedMessage = assemble(message, currentContext);
        if (contextualizedMessage) {
            batch.add(contextualizedMessage);
        }
    };
}
function startLoggerBatch(configuration) {
    var primaryBatch = createLoggerBatch(configuration.logsEndpoint);
    var replicaBatch;
    if (configuration.replica !== undefined) {
        replicaBatch = createLoggerBatch(configuration.replica.logsEndpoint);
    }
    function createLoggerBatch(endpointUrl) {
        return new Batch(new HttpRequest(endpointUrl, configuration.batchBytesLimit), configuration.maxBatchSize, configuration.batchBytesLimit, configuration.maxMessageSize, configuration.flushTimeout);
    }
    return {
        add: function (message) {
            primaryBatch.add(message);
            if (replicaBatch) {
                replicaBatch.add(message);
            }
        },
    };
}
export function buildAssemble(session, configuration, reportError) {
    var errorFilter = createErrorFilter(configuration, reportError);
    return function (message, currentContext) {
        if (!session.isTracked()) {
            return undefined;
        }
        var contextualizedMessage = combine({ service: configuration.service, session_id: session.getId() }, currentContext, getRUMInternalContext(), message);
        if (configuration.beforeSend) {
            var shouldSend = limitModification(contextualizedMessage, FIELDS_WITH_SENSITIVE_DATA, configuration.beforeSend);
            if (shouldSend === false) {
                return undefined;
            }
        }
        if (contextualizedMessage.status === StatusType.error && errorFilter.isLimitReached()) {
            return undefined;
        }
        return contextualizedMessage;
    };
}
function getRUMInternalContext(startTime) {
    var rum = window.DD_RUM;
    return rum && rum.getInternalContext ? rum.getInternalContext(startTime) : undefined;
}
//# sourceMappingURL=startLogs.js.map